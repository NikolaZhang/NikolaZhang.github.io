import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as r,c as o,e as a}from"./app-hGx9Z5MB.js";const t={},c=a('<blockquote><p>装饰器模式，可以在不修改对象外观和功能的情况下添加或者删除对象功能。它可以使用一种对客户端来说是透明的方法来修改对象的功能，也就是使用初始类的子类实例对初始对象进行授权。<br> 装饰器模式来为对象动态地添加了额外的责任，这样就在不使用静态继承的情况下，为修改对象功能提供了灵活的选择。</p></blockquote><p><img src="https://raw.githubusercontent.com/NikolaZhang/image-blog/main/10-decorator/20240119150457.png" alt="20240119150457"></p><h2 id="主要角色" tabindex="-1"><a class="header-anchor" href="#主要角色" aria-hidden="true">#</a> 主要角色</h2><ol><li>抽象构件（Component）：<br> 这是一个接口或抽象类，它定义了被装饰对象的接口，即所有具体组件和装饰器共有的方法。客户端通常通过这个接口与具体的实现类交互。</li><li>具体构件（ConcreteComponent）：<br> 实现了抽象构件接口的具体对象，它是原始对象，具有核心业务功能。装饰器可以用于增强或修改具体构件的行为。</li><li>抽象装饰（Decorator）：<br> 继承自抽象构件，实现了抽象构件的所有方法，并且包含一个指向抽象构件类型的引用，这样就可以在内部持有一个具体构件实例。<br> 抽象装饰为具体装饰器提供了一个统一的接口扩展点，允许在运行时动态地向具体构件添加新的职责或行为。</li><li>具体装饰（ConcreteDecorator）：<br> 是抽象装饰类的子类，除了重写并实现抽象装饰中的方法外，还可以在其基础上增加额外的功能。<br> 具体装饰器可以在调用其持有的具体构件的方法时，先执行自己的附加操作，然后将控制权传递给被装饰的对象，从而达到在不修改原有类的基础上动态扩展功能的目的。</li></ol><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现" aria-hidden="true">#</a> 代码实现</h2><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h3>',6),i=[c];function n(l,h){return r(),o("div",null,i)}const _=e(t,[["render",n],["__file","10-decorator.html.vue"]]);export{_ as default};
