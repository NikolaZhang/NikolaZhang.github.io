import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as c,c as d,f as s,a as e,b as a,d as o,w as n,e as r}from"./app-29bee1fb.js";const u="/images/article/181202/eurekaserver.png",h="/images/article/181202/serverconfig.png",p="/images/article/181202/eurekainstance.png",k={},_=e("blockquote",null,[e("p",null,"每天更新，用于记录未付学习过程中遇到的知识点、问题，及解决方案。")],-1),E=e("h1",{id:"_1-服务治理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-服务治理","aria-hidden":"true"},"#"),a(" 1 服务治理")],-1),m=e("p",null,[a("之前程序的框架结构： "),e("img",{src:u,alt:"结构"})],-1),g=r('<h2 id="_1-1-eureka服务治理基础框架的三个核心要素" tabindex="-1"><a class="header-anchor" href="#_1-1-eureka服务治理基础框架的三个核心要素" aria-hidden="true">#</a> 1.1 Eureka服务治理基础框架的三个核心要素</h2><ul><li>服务注册中心</li></ul><blockquote><p>Eureka提供的服务端，用于提供服务与发现。</p></blockquote><ul><li>服务提供者</li></ul><blockquote><p>提供服务的应用，可以是一切遵循Eureka通讯机制的应用（不限于springboot）。它将自己提供的服务注册到Eureka。</p></blockquote><ul><li>服务消费者</li></ul><blockquote><p>从服务注册中心获取服务列表，从而使消费者可以知道去何处调用需要的服务。可以通过ribbon和feign实现服务消费。</p></blockquote><h2 id="_1-2-服务治理机制" tabindex="-1"><a class="header-anchor" href="#_1-2-服务治理机制" aria-hidden="true">#</a> 1.2 服务治理机制</h2><blockquote><ul><li>服务注册中心1,2相互注册形成高可用集群。</li></ul></blockquote><ul><li>服务提供者注册服务到注册中心。</li><li>服务消费者同样指向注册中心。</li></ul><h3 id="_1-2-1服务提供者" tabindex="-1"><a class="header-anchor" href="#_1-2-1服务提供者" aria-hidden="true">#</a> 1.2.1服务提供者</h3>',11),f=e("code",null,"eureka.client.register-with-eureka=true",-1),b=e("li",null,"服务同步 服务提供者虽然会在不同的注册中心注册，但是当服务注册中心会转发请求到与其相连的其他注册中心，从而实现注册中心间的服务同步。通过服务同步，服务提供者的服务信息就可以通多服务注册中心的任一台获取到。",-1),v=e("li",null,[a("服务续约 服务注册完成后，服务提供者会维护一个心跳，防止EurekaServer“剔除任务”。 "),e("code",null,"eureka.instance.lease-renewal-interval-in-seconds=30"),a(" 设置服务续约任务的调用间隔。 "),e("code",null,"eureka.instance.lease-expiration-duration-in-seconds=90"),a(" 定义服务失效时间。")],-1),S=r('<h3 id="_1-2-2-服务消费者" tabindex="-1"><a class="header-anchor" href="#_1-2-2-服务消费者" aria-hidden="true">#</a> 1.2.2 服务消费者</h3><ul><li><p>获取服务 当我们启动服务消费者的时候，它会发送一个REST请求给服务注册中心，来获取注册的服务清单。EurekaServer会维护一份只读的服务清单返回给客户端，同时该缓存清单会每隔30秒更新一次。 客户端设置 <code>eureka.client.fetch-register=true</code>（虽然这是默认的） <code>eureka.client.fetch-register-interval-seconds=30</code>设置缓存清单更新时间。</p></li><li><p>服务调用 消费者获取服务清单后，通过服务名可以获取：服务实例名和该实例的元数据信息。 在Ribbon中通过轮询的方式进行调用实例，从而实现客户端的负载均衡。 进行服务调用时优先访问同处一个zone中的服务提供方。若访问不到则访问其他的zone。【每一个客户端对应一个region和一个zone】</p></li><li><p>服务下线 当服务实例进行正常关闭时，会触发一个服务下线的REST请求给EurekaServer，服务注册中心收到请求后，将该服务状态设置为下线<code>down</code>（上线为up）。并把下线事件传播出去。</p></li></ul><h3 id="_1-2-3-服务注册中心" tabindex="-1"><a class="header-anchor" href="#_1-2-3-服务注册中心" aria-hidden="true">#</a> 1.2.3 服务注册中心</h3><ul><li>失效剔除 当服务实例非正常下线，服务注册中心未收到下线请求。EurekaServer的定时任务会将清单中超时没有续约的服务剔除。</li><li>自我保护</li></ul>',4),x=r('<p>本地调试时基本会在界面看到这条信息。这就是触发了EurekaServer的自我保护机制。EurekaServer在运行期间，会统计心跳失败比例在15分钟内是否低于85%。eureka会将当前实例信息保护起来，不让其过期。 使用<code>eureka.server.enable-self-preservation=false</code>来关闭保护机制。</p><h2 id="_1-3-配置" tabindex="-1"><a class="header-anchor" href="#_1-3-配置" aria-hidden="true">#</a> 1.3 配置</h2><p>以上所有的应用都可以视为Eureka服务治理体系中的客户端。故，eureka客户端的配置包含两部分：</p><blockquote><ul><li>服务注册相关配置：服务注册中心地址、服务获取间隔时间、可用区域等</li><li>服务实例相关的配置信息：服务实例名称、IP地址、端口号、健康检查路径等。</li></ul></blockquote><h3 id="_1-3-1-服务注册类配置" tabindex="-1"><a class="header-anchor" href="#_1-3-1-服务注册类配置" aria-hidden="true">#</a> 1.3.1 服务注册类配置</h3><p>可以查看<code>org.springframework.cloud.netflix.eureka.EurekaClientConfigBean</code>所有的配置信息都以eureka.client为前缀。</p><ul><li><p>指定注册中心 <code>eureka.client.serviceUrl.defaultZone=http....</code> 配置多个注册中心使用逗号分隔。 <code>http://&lt;username&gt;:&lt;password&gt;@ip:port/...</code>使用安全校验信息。 <code>eureka.client.enable=true</code> 启用Eureka客户端 <img src="'+h+'" alt="其他配置"></p></li><li><p><strong>服务实例类配置</strong> 可以查看<code>org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean</code>所有的配置信息都以eureka.instance为前缀。</p><ul><li>元数据</li></ul><blockquote><p>元数据：Eureka客户端在向注册中心发送注册请求时，用来描述自身服务信息的对象。</p></blockquote><p>标准化元数据<code>eureka.instance.&lt;properties&gt;=&lt;value&gt;</code> 自定义元数据<code>eureka.instance.metedataMap.&lt;key&gt;=&lt;value&gt;</code></p><ul><li><p>实例名配置 同一主机启动多实例时的默认配置规则： <code>${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}</code> 对于实例的命名规则可以使用eureka.instance.instanceId参数进行配置。 设置随机端口：<code>server.port=0</code>或者 <code>server.port=${random.int[10000,19999]}</code> 虽然端口名不同但是实例名还是相同的，需要使用下面的方法设置不同的实例名： <code>eureka.instance.instanceId=${spring.application.name}:${random.int}</code></p></li><li><p>端点配置 当我们为应用设置了context-path时，<code>management.context-path=/hello</code>，监控端点都应该加上这个前缀。需要变更actuator模块的访问的路径。 <code>eureka.instance.statusPageUrlPath=${management.context-path}/info</code><code>eureka.instance.healthCheckUrlPath=${management.context-path}/health</code> 使用绝对路径方式： <code>eureka.instance.healthCheckUrl=https://${eureka.instance.hostname}/health</code><code>eureka.instance.statusPageUrl=https://${eureka.instance.hostname}/info</code><code>eureka.instance.homePageUrl=https://${eureka.instance.hostname}/</code></p></li><li><p>健康监测 当服务不能正常提供时，比如服务所依赖的外部资源出现问题时，此时心跳还是在运行，客户端依旧可以使用非正常服务。这是不合理的。 因此需要更加健全的健康状态维护。方法如下： <em>首先在pom xml中引入actuator模块依赖</em><em>配置参数<code>eureka.client.healthcheck.enable=true</code></em></p></li><li><p>其他配置 <img src="'+p+'" alt="其他配置"></p></li></ul></li></ul><h2 id="_1-4-跨平台支持" tabindex="-1"><a class="header-anchor" href="#_1-4-跨平台支持" aria-hidden="true">#</a> 1.4 跨平台支持</h2><p>Eureka的通信机制使用HTTP的REST接口实现，这也是Eureka同其他服务注册工具的一个关键不同点。HTTP是平台无关的，虽然Eureka Server通过java实现，但是其下微服务应用不限于使用java开发。</p><h3 id="_1-4-1-通信协议" tabindex="-1"><a class="header-anchor" href="#_1-4-1-通信协议" aria-hidden="true">#</a> 1.4.1 通信协议</h3><blockquote><p>Eureka使用Jersey和XStream配合JSON作为servlet和client之间的通讯协议。也可以选择实现自己的协议来代替。</p></blockquote><hr><p>华丽丽的分隔符！</p>',13);function N(T,R){const t=l("font");return c(),d("div",null,[_,E,m,s("more"),g,e("ul",null,[e("li",null,[a("服务注册 服务提供者在启动时会通过发送REST请求的方式将自己注册到Eureka Server上，同时带上自身服务的元数据信息。 Eureka Server接收到这个REST请求后，将元数据信息存储在一个双层结构Map中。"),o(t,{color:"red"},{default:n(()=>[a("第一层key是服务名，第二层key是具体服务的实例名。")]),_:1}),f,a(" 启动注册操作。")]),b,v]),S,o(t,{color:"red"},{default:n(()=>[a("EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.")]),_:1}),x])}const A=i(k,[["render",N],["__file","微服务学习笔记.html.vue"]]);export{A as default};
