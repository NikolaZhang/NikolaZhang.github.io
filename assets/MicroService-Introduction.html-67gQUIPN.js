import{_ as l}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c as r,f as a,e}from"./app-Z38smFUc.js";const o="/images/article/18/microservice.png",c={},d=e('<h1 id="微服务关键技术概要【上】" tabindex="-1"><a class="header-anchor" href="#微服务关键技术概要【上】" aria-hidden="true">#</a> 微服务关键技术概要【上】</h1><p><img src="'+o+'" alt="微服务思维导图"></p><h1 id="路由网关" tabindex="-1"><a class="header-anchor" href="#路由网关" aria-hidden="true">#</a> 路由网关</h1><h2 id="zuul" tabindex="-1"><a class="header-anchor" href="#zuul" aria-hidden="true">#</a> zuul</h2><ul><li>本质是WebServlet，核心是一系列Filter。</li><li>反向代理</li><li>只需要访问Zuul的地址，参数为服务注册名和接口名称。（RESTFUL）</li></ul>',5),t=e('<h2 id="nginx" tabindex="-1"><a class="header-anchor" href="#nginx" aria-hidden="true">#</a> Nginx</h2><ul><li>高性能HTTP服务器&amp;反向代理器</li></ul><blockquote><ol><li>作为web服务器</li><li>负载均衡服务器</li><li>邮件代理服务器</li></ol></blockquote><ul><li>模块</li></ul><blockquote><ol><li>核心</li><li>配置</li><li>事件</li><li>HTTP</li><li>MAIL</li></ol></blockquote><ul><li>对比TOMCAT</li></ul><blockquote><ol><li>Nginx<code>负载均衡、反向代理、处理静态文件</code>有优势。 Nginx 处理静态请求的速度高于 apache。</li><li>TOMCAT是动态解析服务器，处理动态请求，是编译 JSP\\Servlet 的容器。</li><li>Nginx 有<code>动态分离机制</code>，静态请求直接就可以通过 Nginx 处理，动态请求才转发请求到后台交由 Tomcat 进行处理。</li></ol></blockquote><hr><h1 id="服务中心" tabindex="-1"><a class="header-anchor" href="#服务中心" aria-hidden="true">#</a> 服务中心</h1><h2 id="eureka" tabindex="-1"><a class="header-anchor" href="#eureka" aria-hidden="true">#</a> Eureka</h2><ul><li>使用REST服务</li><li>用于云端服务发现</li><li>实现云端中间层服务发现和故障转移</li><li>特点</li></ul><blockquote><ol><li>缓存服务注册表，定期更新</li><li>服务提供者挂掉，移除客户端</li><li>自我保护，从相邻节点获取注册表信息</li></ol></blockquote><h2 id="zookeeper" tabindex="-1"><a class="header-anchor" href="#zookeeper" aria-hidden="true">#</a> zookeeper</h2><ul><li>服务注册与发现</li><li>通过 Watcher 机制实现 Push 模型，服务注册信息的变更能够及时通知服务消费方。</li><li>角色（其他的注册发现没有）解释</li></ul><blockquote><ol><li><code>Leader</code> 节点是 Zookeeper 集群工作的核心，负责进行选举投票的<br> 发起和决议，更新系统状态；</li><li><code>Follower</code> 节点是 Zookeeper 集群状态的跟随者，用于接收客户端<br> 的请求并向客户端返回结果，在选举过程中参与投票。</li><li><code>Observer</code>可以接受客户端连接，将写请求转发给 Leader 节点，但 Observer 不参加投票过程，<br> 只同步 Leader 节点的状态，Observer 的目的是为了扩展系统，提高读取速度。</li></ol></blockquote><h2 id="servicecenter" tabindex="-1"><a class="header-anchor" href="#servicecenter" aria-hidden="true">#</a> ServiceCenter</h2><ul><li>通过ServiceCenter提供的接口可以检索微服务信息</li></ul><h2 id="服务生产与消费" tabindex="-1"><a class="header-anchor" href="#服务生产与消费" aria-hidden="true">#</a> 服务生产与消费</h2><ul><li>Eureka服务治理三角色</li></ul><blockquote><ol><li>服务注册中心</li><li>服务提供者</li><li>服务消费者</li></ol></blockquote><h2 id="ribbon" tabindex="-1"><a class="header-anchor" href="#ribbon" aria-hidden="true">#</a> Ribbon</h2><ul><li>提供客户端的软件负载均衡算法</li><li>Ribbon 的负载均衡策略</li></ul><blockquote><ol><li>简单轮询负载均衡</li><li>随机负载均衡，随机选择up状态的server</li><li>加权响应时间负载均衡，时间越长，越不被选中</li><li>区域感知轮询负载均衡，复合判断 server 所在区域的性能和 server 的可用性选择 server。</li></ol></blockquote><hr><h1 id="缓存服务" tabindex="-1"><a class="header-anchor" href="#缓存服务" aria-hidden="true">#</a> 缓存服务</h1><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> redis</h2><ul><li>数据库，缓存，消息中间件</li><li>特征</li></ul><blockquote><ol><li>单线程，消除串行控制开销</li><li>支持数据持久化</li><li>分布式架构，读写分离</li><li>数据结构多样</li><li>支持数据备份</li></ol></blockquote><ul><li>Redis Cluster</li></ul><blockquote><ol><li>无中心结构，主从结构</li></ol></blockquote><p><em>持续更新，以后会在CSDN上发布详细博客</em></p>',31);function h(u,n){return i(),r("div",null,[d,a("more"),t])}const k=l(c,[["render",h],["__file","MicroService-Introduction.html.vue"]]);export{k as default};
