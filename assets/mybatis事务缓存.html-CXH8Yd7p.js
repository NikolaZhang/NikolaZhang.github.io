import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as c,c as t,e as o}from"./app-CYrfdzXE.js";const i={};function n(l,e){return c(),t("div",null,e[0]||(e[0]=[o('<h2 id="事务缓存-transactionalcache" tabindex="-1"><a class="header-anchor" href="#事务缓存-transactionalcache" aria-hidden="true">#</a> 事务缓存 TransactionalCache</h2><p><code>TransactionalCacheManager</code>用于管理所有的<code>TransactionalCache</code>事务缓存。其结构为<code>Map&lt;Cache, TransactionalCache&gt;</code>。</p><p>通过<code>MapperStatement</code>中的<code>Cache</code>，从事务缓存管理器中获取<code>TransactionalCache</code>，通过<code>TransactionalCache</code>进行缓存操作。</p><p><code>TransactionalCache</code>中存在一个<code>Map&lt;Object, Object&gt; entriesToAddOnCommit</code>用于存储缓存记录；<code>Set&lt;Object&gt; entriesMissedInCache</code>用于记录未命中的缓存记录。每次查询、更新操作，事务管理器都会对这两个缓存进行操作，此时临时缓存的数据还没有写入二级缓存，只有执行提交操作，这两个缓存数据才会正式写入二级缓存。这种操作方式，符合数据库的事务特性，即：事务提交之前，只操作临时缓存，不操作二级缓存，因此不会影响其他事务；事务提交之后，缓存写入二级缓存，此时对所有事务可见。对二级缓存的操作，是整个事务一起提交的，符合原子特性。</p><p>为什么要记录未命中缓存的key？缓存未命中的key可以防止缓存穿透，当大量请求数据库不存在的数据时，通过缓存，可以防止频繁查询数据库。</p><p>事务缓存存在以下操作：</p><ul><li>添加缓存记录：<code>putObject(Object key, Object value)</code></li><li>获取缓存记录：<code>getObject(Object key)</code></li><li>清空缓存：<code>clear()</code></li><li>提交事务：<code>commit()</code></li><li>回滚事务：<code>rollback()</code></li></ul><p>下面是对这几个操作的流程解析：</p><p><img src="https://raw.githubusercontent.com/NikolaZhang/image-blog/main/mybatis缓存架构/Snipaste_2024-11-04_16-06-42.png" alt="Snipaste_2024-11-04_16-06-42"><br><img src="https://raw.githubusercontent.com/NikolaZhang/image-blog/main/mybatis缓存架构/Snipaste_2024-11-04_16-07-08.png" alt="Snipaste_2024-11-04_16-07-08"><br><img src="https://raw.githubusercontent.com/NikolaZhang/image-blog/main/mybatis缓存架构/Snipaste_2024-11-04_16-07-50.png" alt="Snipaste_2024-11-04_16-07-08"></p><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>一定需要注意的是，二级缓存的写入发生在事务提交或者回滚阶段，而不是在查询阶段。</p></div>',10)]))}const d=a(i,[["render",n],["__file","mybatis事务缓存.html.vue"]]);export{d as default};
